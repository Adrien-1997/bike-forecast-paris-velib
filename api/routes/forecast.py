# api/routes/forecast.py

"""Forecast endpoints (batch forecasts served from GCS or local files).

This router exposes **read-only** endpoints that proxy the batch forecasts
generated by the backend jobs and stored under the **new** serving layout:

    <SERVING_FORECAST_PREFIX>/latest/
        manifest.json
        h{H}/
            forecast.json

Notes
-----
- Horizons are configured via `FORECAST_SUPPORTED` (e.g. "15,60").
- The API does **not** recompute forecasts; it only reads JSON from
  GCS or local disk depending on STORAGE_BACKEND.
- JSON is sanitized before returning (non-finite floats → null).
- Only two endpoints are exposed:
    - GET /forecast/manifest      -> latest/manifest.json
    - GET /forecast/latest?h=H    -> latest/h{H}/forecast.json
"""

from __future__ import annotations

import os
import json
import math
from pathlib import Path
from typing import Tuple, List, Any, Dict

from fastapi import APIRouter, Request, HTTPException, Query
from fastapi.responses import JSONResponse

# google-cloud-storage is optional: required only when STORAGE_BACKEND != "local"
try:  # pragma: no cover
    from google.cloud import storage  # type: ignore
except Exception:  # pragma: no cover
    storage = None  # type: ignore

router = APIRouter(prefix="/serving/forecast", tags=["serving-forecast"])


# ───────────────────────────── Backend selection (local vs GCS) ─────────────────────────────

STORAGE_BACKEND = os.getenv("STORAGE_BACKEND", "gcs").lower()
USE_LOCAL = STORAGE_BACKEND == "local"

# Repo root ≈ <repo>/
REPO_ROOT = Path(__file__).resolve().parents[2]
DATA_ROOT = Path(os.getenv("DATA_ROOT", REPO_ROOT / "data"))

# GCS prefix used to map to local files when STORAGE_BACKEND=local
GCS_LOCAL_ROOT_PREFIX = (
    os.getenv("GCS_LOCAL_ROOT_PREFIX", "gs://velib-forecast-472820_cloudbuild/velib/").rstrip("/")
    + "/"
)

# ── Helpers URIs ──────────────────────────────────────────────────────────────


def _split_gs(uri: str) -> Tuple[str, str]:
    """Split a `gs://bucket/key` URI into `(bucket, key)`."""
    if not uri.startswith("gs://"):
        raise ValueError(f"Bad GCS URI: {uri}")
    bucket, key = uri[5:].split("/", 1)
    return bucket, key


def _serving_prefix_or_500() -> str:
    """Read the logical serving prefix (gs://...)."""
    raw = os.environ.get("GCS_FORECAST_PREFIX", "") or os.environ.get("SERVING_FORECAST_PREFIX", "")
    val = raw.strip().strip("'\"").rstrip("/")
    if not val.startswith("gs://"):
        raise HTTPException(status_code=500, detail="GCS_FORECAST_PREFIX manquant ou invalide")
    return val


def _supported_horizons() -> List[int]:
    """Return sorted supported horizons (minutes) from FORECAST_SUPPORTED."""
    envs = os.environ.get("FORECAST_SUPPORTED", "15,60")
    try:
        vals = sorted({int(x.strip()) for x in envs.split(",") if x.strip()})
        return vals or [15]
    except Exception:
        return [15]


def _validate_h(h: int) -> int:
    """Validate h is supported and return it."""
    hh = int(h)
    supported = set(_supported_horizons())
    if hh not in supported:
        raise HTTPException(status_code=400, detail=f"h must be in {sorted(supported)}")
    return hh


# ── Backend readers (local / GCS) ─────────────────────────────────────────────


def _local_read_json(gs_uri: str) -> Dict[str, Any]:
    """Read a JSON file from local disk, mapping from a gs:// URI."""
    if not gs_uri.startswith(GCS_LOCAL_ROOT_PREFIX):
        raise FileNotFoundError(f"Local mapping failed for URI: {gs_uri}")
    rel = gs_uri[len(GCS_LOCAL_ROOT_PREFIX) :]
    path = DATA_ROOT / rel.lstrip("/")
    if not path.exists():
        raise FileNotFoundError(f"Local file not found: {path}")
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        raise ValueError(f"Invalid JSON in local file {path}: {e}") from e


def _gcs_read_json(gs_uri: str) -> Dict[str, Any]:
    """Download a JSON blob from GCS and parse it."""
    if storage is None:
        raise RuntimeError("google-cloud-storage is required when STORAGE_BACKEND != 'local'")
    bkt, key = _split_gs(gs_uri)
    client = storage.Client()
    blob = client.bucket(bkt).blob(key)
    if not blob.exists():
        raise FileNotFoundError(f"GCS blob not found: {gs_uri}")
    data = blob.download_as_bytes()
    try:
        return json.loads(data.decode("utf-8"))
    except Exception as e:
        raise ValueError(f"Invalid JSON in {gs_uri}: {e}") from e


def _read_json_any(gs_uri: str) -> Dict[str, Any]:
    """Read JSON either from local disk or GCS depending on STORAGE_BACKEND."""
    return _local_read_json(gs_uri) if USE_LOCAL else _gcs_read_json(gs_uri)


# ── JSON sanitization & proxy ─────────────────────────────────────────────────


def _json_sanitize(obj):
    """Recursively sanitize JSON-like structures (NaN/±Inf -> null)."""
    if isinstance(obj, dict):
        return {k: _json_sanitize(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [_json_sanitize(v) for v in obj]
    if isinstance(obj, float):
        return obj if math.isfinite(obj) else None
    return obj


def _proxy_json(gs_uri: str, request: Request, ttl: int = 60) -> JSONResponse:
    """Generic "JSON → HTTP JSON" proxy with cache headers."""
    try:
        payload = _read_json_any(gs_uri)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Document non trouvé")
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Erreur lecture forecast: {e}")

    safe = _json_sanitize(payload)
    resp = JSONResponse(safe)
    resp.headers["Cache-Control"] = f"public, max-age={max(0, int(ttl))}"
    resp.headers.setdefault("Access-Control-Allow-Origin", "*")
    return resp


def _base_latest(serving_prefix: str) -> str:
    """Return <GCS_FORECAST_PREFIX>/latest."""
    return f"{serving_prefix}/latest"


# ── Endpoints (ONLY: manifest + forecast) ─────────────────────────────────────


@router.get("/")
def forecast_latest(
    request: Request,
    h: int = Query(15, description="Horizon en minutes (ex: 15, 60)"),
):
    """Latest forecast for a given horizon (latest-only)."""
    hh = _validate_h(h)
    base = _base_latest(_serving_prefix_or_500())
    gs_uri = f"{base}/h{hh}/forecast.json"
    return _proxy_json(gs_uri, request, ttl=60)
