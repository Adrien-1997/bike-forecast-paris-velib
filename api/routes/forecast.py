# api/routes/forecast.py

"""Forecast endpoints (batch forecasts served from GCS or local files).

This router exposes **read-only** endpoints that proxy the batch forecasts
generated by the backend jobs and stored under:

    SERVING_FORECAST_PREFIX/h{H}/latest.json

Key ideas:
- Horizons are configured via the `FORECAST_SUPPORTED` env (e.g. "15,60").
- The API does **not** recompute forecasts; it only reads JSON from
  GCS or local disk depending on STORAGE_BACKEND.
- JSON is sanitized before returning (non-finite floats → null).
- Cache headers are set to allow short-lived client-side caching.

Typical usage from the UI:
- GET `/forecast/available` : discover configured horizons + prefix
- GET `/forecast/latest?h=15` : retrieve the latest 15-minute forecast bundle
"""

from __future__ import annotations
import os
import json
import math
from pathlib import Path
from typing import Tuple, List

from fastapi import APIRouter, Request, HTTPException, Query
from fastapi.responses import JSONResponse

# google-cloud-storage is optional: required only when STORAGE_BACKEND != "local"
try:  # pragma: no cover
    from google.cloud import storage  # type: ignore
except Exception:  # pragma: no cover
    storage = None  # type: ignore

router = APIRouter(prefix="/forecast", tags=["forecast"])


# ───────────────────────────── Backend selection (local vs GCS) ─────────────────────────────

STORAGE_BACKEND = os.getenv("STORAGE_BACKEND", "gcs").lower()
USE_LOCAL = STORAGE_BACKEND == "local"

# Repo root ≈ <repo>/
REPO_ROOT = Path(__file__).resolve().parents[2]
DATA_ROOT = Path(os.getenv("DATA_ROOT", REPO_ROOT / "data"))

# GCS prefix used to map to local files when STORAGE_BACKEND=local
# Example:
#   gs://velib-forecast-472820_cloudbuild/velib/serving/forecast/h15/latest.json
#   → DATA_ROOT / "serving/forecast/h15/latest.json"
GCS_LOCAL_ROOT_PREFIX = (
    os.getenv(
        "GCS_LOCAL_ROOT_PREFIX",
        "gs://velib-forecast-472820_cloudbuild/velib/",
    ).rstrip("/")
    + "/"
)


# ── Helpers URIs ──────────────────────────────────────────────────────────────

def _split_gs(uri: str) -> Tuple[str, str]:
    """Split a `gs://bucket/key` URI into `(bucket, key)`."""
    if not uri.startswith("gs://"):
        raise ValueError(f"Bad GCS URI: {uri}")
    bucket, key = uri[5:].split("/", 1)
    return bucket, key


def _serving_prefix_or_500() -> str:
    """Return SERVING_FORECAST_PREFIX from env or raise a 500 if invalid.

    The env is normalized by stripping extra quotes and trailing slashes,
    and must start with `gs://` (even in local mode; it will be mapped to DATA_ROOT).
    """
    raw = os.environ.get("SERVING_FORECAST_PREFIX", "")
    val = raw.strip().strip("'\"").rstrip("/")
    if not val.startswith("gs://"):
        print(f"[forecast] SERVING_FORECAST_PREFIX invalide. Lu='{raw}' → '{val}'")
        raise HTTPException(status_code=500, detail="SERVING_FORECAST_PREFIX manquant ou invalide")
    return val


# ── Backend readers (local / GCS) ─────────────────────────────────────────────

def _local_read_json(gs_uri: str) -> dict:
    """Read a JSON file from local disk, mapping from a gs:// URI.

    Mapping rule (when STORAGE_BACKEND=local):
      GCS_LOCAL_ROOT_PREFIX → DATA_ROOT/

    Example:
      GCS_LOCAL_ROOT_PREFIX = "gs://velib-forecast-472820_cloudbuild/velib/"
      gs_uri = "gs://velib-forecast-472820_cloudbuild/velib/serving/forecast/h15/latest.json"
      → DATA_ROOT / "serving/forecast/h15/latest.json"
    """
    if not gs_uri.startswith(GCS_LOCAL_ROOT_PREFIX):
        raise FileNotFoundError(f"Local mapping failed for URI: {gs_uri}")
    rel = gs_uri[len(GCS_LOCAL_ROOT_PREFIX):]
    path = DATA_ROOT / rel.lstrip("/")
    if not path.exists():
        raise FileNotFoundError(f"Local file not found: {path}")
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        raise ValueError(f"Invalid JSON in local file {path}: {e}") from e


def _gcs_read_json(gs_uri: str) -> dict:
    """Download a JSON blob from GCS and parse it into a dict.

    Parameters
    ----------
    gs_uri : str
        GCS URI to read (must exist and contain valid JSON).

    Returns
    -------
    dict
        Parsed JSON object.
    """
    if storage is None:
        raise RuntimeError("google-cloud-storage is required when STORAGE_BACKEND != 'local'")
    bkt, key = _split_gs(gs_uri)
    client = storage.Client()
    blob = client.bucket(bkt).blob(key)
    if not blob.exists():
        raise FileNotFoundError(f"GCS blob not found: {gs_uri}")
    data = blob.download_as_bytes()
    try:
        return json.loads(data.decode("utf-8"))
    except Exception as e:
        raise ValueError(f"Invalid JSON in {gs_uri}: {e}") from e


def _read_json_any(gs_uri: str) -> dict:
    """Read JSON either from local disk or GCS depending on STORAGE_BACKEND."""
    if USE_LOCAL:
        return _local_read_json(gs_uri)
    return _gcs_read_json(gs_uri)


# ── JSON sanitization & proxy ─────────────────────────────────────────────────

def _json_sanitize(obj):
    """Recursively sanitize a JSON-like structure for transport.

    - dict / list: recurse,
    - float: if not finite (NaN/inf) → None,
    - otherwise: unchanged.

    This avoids JSON encoding issues and keeps the UI simple.
    """
    if isinstance(obj, dict):
        return {k: _json_sanitize(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [_json_sanitize(v) for v in obj]
    if isinstance(obj, float):
        return obj if math.isfinite(obj) else None
    return obj


def _proxy_json(gs_uri: str, request: Request, ttl: int = 60) -> JSONResponse:
    """Generic "JSON → HTTP JSON" proxy with basic caching headers.

    Parameters
    ----------
    gs_uri : str
        Logical URI (gs://...). Will be mapped to local disk if STORAGE_BACKEND=local.
    request : Request
        FastAPI request (unused today, kept for potential future needs).
    ttl : int, default 60
        Cache TTL (seconds) used for `Cache-Control`.

    Returns
    -------
    fastapi.responses.JSONResponse
        Response with sanitized JSON payload.

    Raises
    ------
    HTTPException
        404 if the document is missing; 502 on backend / JSON errors.
    """
    try:
        payload = _read_json_any(gs_uri)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Document non trouvé")
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"Erreur lecture forecast: {e}")
    safe = _json_sanitize(payload)
    resp = JSONResponse(safe)
    resp.headers["Cache-Control"] = f"public, max-age={max(0, int(ttl))}"
    # Allow embedding the widget / calling the endpoint from any origin if needed.
    resp.headers.setdefault("Access-Control-Allow-Origin", "*")
    return resp


# ── Horizons supportés (comme perf utilise ?h=) ───────────────────────────────

def _supported_horizons() -> List[int]:
    """Return the sorted list of supported horizons (in minutes).

    Values are read from `FORECAST_SUPPORTED`, e.g. "15,60".
    Defaults to [15, 60] if unset or invalid; if parsing yields an empty set,
    falls back to [15].
    """
    envs = os.environ.get("FORECAST_SUPPORTED", "15,60")
    try:
        vals = sorted({int(x.strip()) for x in envs.split(",") if x.strip()})
        return vals or [15]
    except Exception:
        return [15]


def _validate_h(h: int) -> None:
    """Validate that `h` is one of the supported horizons, else raise 400."""
    supported = set(_supported_horizons())
    if h not in supported:
        raise HTTPException(status_code=400, detail=f"h must be in {sorted(supported)}")


# ── Endpoints (style perf : 1 route + ?h=) ────────────────────────────────────

@router.get("/available")
def forecast_available():
    """Return metadata about available forecast horizons and serving prefix.

    Response example:
    -----------------
    {
      "prefix": "gs://.../serving/forecast",
      "horizons": [15, 60],
      "time_travel": "latest uniquement",
      "docs": ["latest"],
      "examples": [
        "/forecast/latest?h=15",
        "/forecast/latest?h=60"
      ]
    }
    """
    return {
        "prefix": os.environ.get("SERVING_FORECAST_PREFIX", ""),
        "horizons": _supported_horizons(),
        "time_travel": "latest uniquement",
        "docs": ["latest"],
        "examples": [
            "/forecast/latest?h=15",
            "/forecast/latest?h=60",
        ],
    }


@router.get("/latest")
def forecast_latest(
    request: Request,
    h: int = Query(15, description="Horizon en minutes (ex: 15, 60)"),
):
    """
    Proxy the latest forecast JSON for a given horizon.

    Logical path:
        SERVING_FORECAST_PREFIX/h{h}/latest.json

    - In GCS mode, this is a real GCS URI and is read via google-cloud-storage.
    - In local mode, the gs:// prefix is mapped under DATA_ROOT using
      GCS_LOCAL_ROOT_PREFIX.

    Parameters
    ----------
    request : Request
        Incoming FastAPI request.
    h : int, query
        Forecast horizon in minutes (must be in `_supported_horizons()`).

    Returns
    -------
    fastapi.responses.JSONResponse
        Sanitized JSON payload with `Cache-Control` set.
    """
    _validate_h(h)
    base = _serving_prefix_or_500()
    gs_uri = f"{base}/h{int(h)}/latest.json"
    return _proxy_json(gs_uri, request, ttl=60)
